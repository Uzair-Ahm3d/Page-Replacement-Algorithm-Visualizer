### **Technical Report: Page Replacement Algorithm Visualizer:**

###  

#### **1.0 Introduction:**  

This report details the development and functionality of the Page Replacement Algorithm 

Visualizer. In modern computing, Operating Systems must manage a limited amount of physical 

memory (RAM). When the memory is full, the system must decide which data to remove to 

make room for new information. This software provides a visual and mathematical analysis of 

the strategies, known as algorithms, used to solve this problem.

&nbsp; 

#### **2.0 Fundamental Concepts:**  

To understand the performance metrics within this project, two key terms are defined:  

• Page Hit: Occurs when the requested data is already present in the memory frames. This 

results in high-speed processing and no overhead.  

• Page Fault: Occurs when the requested data is missing from memory. The system must 

stop to retrieve the data from the disk, which creates a significant performance delay.  

• Reference String: The sequence of memory requests made by a process. This acts as the 

input for our simulations.

&nbsp; 

#### **3.0 Algorithm Analysis:**  

The visualizer implements four distinct logic models to demonstrate how memory behaves 

under different workloads.  



##### **3.1 First-In-First-Out (FIFO):**  

The FIFO algorithm follows a strict chronological order. It is modeled after a standard queue 

where the first item added to memory is the first item targeted for removal.  

• Mechanism: The system tracks the arrival order of each page. When memory is full, the 

page that has been in memory the longest is evicted.  

• Observation: While simple to implement, it does not consider how often a page is used. 

This can lead to Belady’s Anomaly, a situation where providing more memory frames 

actually increases the number of page faults.  



##### **3.2 Least Recently Used (LRU):**  

The LRU algorithm operates on the principle of "Temporal Locality." It assumes that if a page 

has been used recently, it will likely be used again soon.  

• Mechanism: The system maintains a record of when each page was last accessed. When 

a replacement is needed, the page that has been untouched for the longest period is 

removed.  

• Observation: This is generally much more efficient than FIFO because it keeps frequently 

used data available. However, it requires more processing power to constantly update 

timestamps for every access. 

&nbsp;

##### **3.3 Optimal Algorithm (OPT):**  

The Optimal algorithm serves as the theoretical benchmark for the visualizer. It is designed to 

provide the lowest possible number of page faults for any given sequence.  

• Mechanism: The algorithm analyzes all future page requests. It chooses to remove the 

page that will not be used for the longest time in the future.  

• Observation: This is a "perfect" algorithm that cannot be used in real-time systems 

because computers cannot predict future requests. It serves as a "Gold Standard" to 

measure how well other algorithms are performing. 

&nbsp;

##### **3.4 Clock (Second-Chance) Algorithm:**  

The Clock algorithm is a practical and efficient approximation of the LRU method. It organizes 

memory frames in a circular structure.  

• Mechanism: A pointer moves around the circle like a clock hand. Each page has a "Use  

Bit." o  If a page is accessed, its bit is set to 1. o  

When a fault occurs, the hand 

checks the current page. If the bit is 1, it is changed to 0 (giving it a "second 

chance") and the hand moves to the next page.  

o  If the bit is 0, that page is immediately replaced.  

• Observation: This provides a smart balance, offering performance close to LRU but with 

much lower technical overhead.

&nbsp; 

#### **4.0 Technical Infrastructure:**  

The system architecture utilizes modern web technologies to ensure precision and 

responsiveness.  

• Core Logic: Built with TypeScript, ensuring that the mathematical calculations for page 

faults are accurate and the code is structurally sound.  

• User Interface: Developed using React 19, allowing for real-time updates as the user 

steps through the simulation or changes the frame count.  

• Styling: Implemented via Tailwind CSS, providing a clean, dark-themed interface that is 

easy to read and fully responsive for mobile users.  

• Data Visualization: Utilizes Recharts to generate comparative bar graphs, allowing users 

to see the efficiency of each algorithm side-by-side.  



### **5.0 Conclusion:**  

The Page Replacement Algorithm Visualizer successfully bridges the gap between abstract 

Operating System theory and practical understanding. By providing a step-by-step playback of 

memory transitions, the tool allows users to witness exactly how different logic models impact 

system performance.  

The data generated by the tool confirms that while FIFO is the easiest to build, LRU and Clock 

offer significantly better performance for most real-world tasks. The inclusion of the Optimal 

algorithm provides a vital reference point, demonstrating how close modern heuristics can get 

to perfect efficiency. This project serves as an essential resource for students and professionals 

looking to master the complexities of memory management. 
